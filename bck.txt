
struct taskStruct {
	// void (*functionPointer)(struct taskStruct *task);
	std::function<void(taskStruct *task)> functionPointer;
	struct taskStruct *next = NULL;
	volatile uint32_t _delay = 0;
	volatile uint32_t delay = 0;
	bool _single = false;
};


typedef uint32_t task;

struct taskStruct *tasksMain;
struct taskStruct *tasksInterrupt;

void lol2() {
    struct taskStruct *tempMain = tasksMain;
		while (tempMain != NULL) {
			if(tempMain->_delay > 0) {
				tempMain->_delay--;
			}
			tempMain = tempMain->next;
		}

		struct taskStruct *tempInterrupt = tasksInterrupt, *old;
		while (tempInterrupt != NULL) {
			if(tempInterrupt->_delay > 0) {
				tempInterrupt->_delay--;
			}
			if(tempInterrupt->_delay == 0) {
				tempInterrupt->functionPointer(tempInterrupt);
				tempInterrupt->_delay = tempInterrupt->delay;

				if(tempInterrupt->_single) {
					if(tempInterrupt == tasksInterrupt) {
						tasksInterrupt=tempInterrupt->next;
					} else {
						old->next = tempInterrupt->next;
					}
					free(tempInterrupt);
				}
			} else {
				old = tempInterrupt;
				tempInterrupt = tempInterrupt->next;
			}
			// tempInterrupt = tempInterrupt->next;
		}
}
void lol () {
    struct taskStruct *temp = tasksMain, *old;
		while (temp != NULL) {
			if(temp->_delay == 0) {
				temp->functionPointer(temp);
                temp->_delay = temp->delay;

				if(temp->_single) {
					if(temp == tasksMain) {
						tasksMain=temp->next;
					} else {
						old->next = temp->next;
					}
					free(temp);
				}
			} else {
				old = temp;
				temp = temp->next;
			}
		}
}


task *addTaskMain(std::function<void(taskStruct *task)> functionPointer, uint32_t delay, bool single = false);
// task *addTaskMain(void (*functionPointer)(struct taskStruct *task), uint32_t delay, bool single = false);
// task *addTaskInterrupt(void (*functionPointer)(struct taskStruct *task), uint32_t delay, bool single = false);
task *addTaskInterrupt(std::function<void(taskStruct *task)> functionPointer, uint32_t delay, bool single = false);

void removeTaskMain(task *task);




task *addTaskMain2(std::function<void(taskStruct *task)> functionPointer, uint32_t delay, bool single) {
	return nullptr;
}

// task *addTaskMain(void (*functionPointer)(struct taskStruct *task), uint32_t delay, bool single) {
task *addTaskMain(std::function<void(taskStruct *task)> functionPointer, uint32_t delay, bool single) {
	struct taskStruct *temp = tasksMain, *r;
	if(tasksMain==NULL) {
		temp = (struct taskStruct *)malloc(sizeof(struct taskStruct));
		temp->functionPointer=functionPointer;
		temp->delay=delay;
		temp->_delay=delay;
		temp->_single=single;
		temp->next=NULL;
		tasksMain=temp;
		return (task*)temp;
	} else {
		while(temp->next != NULL) temp = temp->next;
		r = (struct taskStruct*)malloc(sizeof(struct taskStruct));
		r->functionPointer=functionPointer;
		r->next=NULL;
		r->delay=delay;
		r->_delay=delay;
		r->_single=single;
		temp->next=r;
		return (task*)r;
	}
}
// task *addTaskInterrupt(void (*functionPointer)(struct taskStruct *task), uint32_t delay, bool single) {
task *addTaskInterrupt(std::function<void(taskStruct *task)> functionPointer, uint32_t delay, bool single) {
	struct taskStruct *temp = tasksInterrupt, *r;
	if(tasksInterrupt==NULL) {
		temp = (struct taskStruct *)malloc(sizeof(struct taskStruct));
		temp->functionPointer=functionPointer;
		temp->next=NULL;
		temp->delay=delay;
		temp->_delay=delay;
		temp->_single=single;
		tasksInterrupt=temp;
		return (task*)temp;
	} else {
		while(temp->next != NULL) temp = temp->next;
		r = (struct taskStruct*)malloc(sizeof(struct taskStruct));
		r->functionPointer=functionPointer;
		r->next=NULL;
		r->delay=delay;
		r->_delay=delay;
		r->_single=single;
		temp->next=r;
		return (task*)r;
	}
}